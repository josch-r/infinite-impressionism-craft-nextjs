import { Element, ElementModel } from "@/interfaces/element";
import connectDb from "@/libs/connect-db";
import type { NextApiRequest, NextApiResponse } from "next";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

type ResponseData = {
  message: string;
  element?: Element;
  discovered?: boolean;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  const w1 = req.query.word1 as string;
  const w2 = req.query.word2 as string;

  if (!w1 || !w2) {
    res.status(400).json({ message: "Bad Request" });
    return;
  }

  await connectDb();

  // Normalize and sort words
  const word1 = w1.toLowerCase();
  const word2 = w2.toLowerCase();
  const sortedWord1 = word1 > word2 ? word1 : word2;
  const sortedWord2 = word1 > word2 ? word2 : word1;

  // Check if combination already exists
  const existingElement = await ElementModel.findOne({
    word1: sortedWord1,
    word2: sortedWord2,
  });

  if (existingElement) {
    return res.status(200).json({
      message: "Element already exists",
      element: {
        emoji: existingElement.emoji,
        text: existingElement.text,
        discovered: false,
      },
    });
  }

  // Generate new combination via OpenAI
  try {
    const chatCompletion = await openai.chat.completions.create({
      messages: [
        {
          role: "system",
          content: `
          You are a linguistics expert.
          Generate a meaningful word that represents or relates to the two provided words.

          Your response must follow this exact format:
          [emoji],[word in the same language as the input words]
          
          Example 1:
          air and water = 💧,rain

          Example 2:
          wind and sun = 🌬️,breeze

          Example 3:
          fire and water = 🔥,steam

          Example 4:
          earth and water = 🌊,mud

          Example 5:
          earth and fire = 🌋,lava
          `,
        },
        { role: "user", content: `${sortedWord1} and ${sortedWord2} =` },
      ],
      model: "gpt-4o-mini",
      max_tokens: 512,
    });

    const output = chatCompletion.choices[0]?.message?.content?.trim();
    if (!output) {
      throw new Error("No output generated by OpenAI");
    }

    // Parse the output
    const splitOutput = output.split(",");
    if (splitOutput.length !== 2) {
      throw new Error("Invalid format in OpenAI response");
    }

    const [emoji, text] = splitOutput.map((item) => item.trim());
    const normalizedText = text.toLowerCase();

    // Check if generated text already exists in the database
    const existingElementByText = await ElementModel.findOne({
      text: normalizedText,
    });

    if (existingElementByText) {
      return res.status(200).json({
        message: "Text already exists",
        element: {
          emoji: existingElementByText.emoji,
          text: existingElementByText.text,
          discovered: false,
        },
      });
    }

    // Save the new element
    const newElement = new ElementModel({
      word1: sortedWord1,
      word2: sortedWord2,
      emoji,
      text: normalizedText,
    });
    await newElement.save();

    return res.status(200).json({
      message: "New element created",
      element: {
        emoji,
        text: normalizedText,
        discovered: true,
      },
    });
  } catch (error) {
    console.error("Error generating or saving element:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
}
